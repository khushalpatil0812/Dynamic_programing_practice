// Tabulation Approach - Bottom-Up DP
class HouseRobber2 {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];

        // Case 1: Exclude last house (rob from 0 to n-2)
        int[] dp1 = new int[n];
        Arrays.fill(dp1, -1);
        dp1[0] = nums[0];
        dp1[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i <= n - 2; i++) {
            dp1[i] = Math.max(nums[i] + dp1[i - 2], dp1[i - 1]);
        }

        // Case 2: Exclude first house (rob from 1 to n-1)
        int[] dp2 = new int[n];
        Arrays.fill(dp2, -1);
        dp2[0] = 0;
        dp2[1] = nums[1];

        for (int i = 2; i <= n - 1; i++) {
            dp2[i] = Math.max(nums[i] + dp2[i - 2], dp2[i - 1]);
        }
        
        return Math.max(dp1[n - 2], dp2[n - 1]);
    }
}

/*
????????????????????????????????????????????????????????????????????????
  Alternative Implementation: Memoization (Top-Down DP)
  Time: O(n) | Space: O(n)
????????????????????????????????????????????????????????????????????????

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
 
        // Case 1: exclude last house
        int[] dp1 = new int[n];
        Arrays.fill(dp1, -1);
        int case1 = robLinear(nums, 0, n - 2, dp1);
 
        // Case 2: exclude first house
        int[] dp2 = new int[n];
        Arrays.fill(dp2, -1);
        int case2 = robLinear(nums, 1, n - 1, dp2);
 
        return Math.max(case1, case2);
    }

    private int robLinear(int[] nums, int index, int end, int[] dp) {
        if (index > end) return 0;
        if (dp[index] != -1) return dp[index];

        int pick = nums[index] + robLinear(nums, index + 2, end, dp);
        int skip = robLinear(nums, index + 1, end, dp);
        return dp[index] = Math.max(pick, skip);
    }
}
*/

/*
????????????????????????????????????????????????????????????????????????
  Naive Implementation: Pure Recursion (TLE Expected)
  Time: O(2^n) | Space: O(n) - recursion stack
????????????????????????????????????????????????????????????????????????

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        
        // Case 1: exclude last house
        int case1 = robLinear(nums, 0, n - 2);
        
        // Case 2: exclude first house
        int case2 = robLinear(nums, 1, n - 1);
        
        return Math.max(case1, case2);
    }

    private int robLinear(int[] nums, int index, int end) {
        if (index > end) return 0;

        int pick = nums[index] + robLinear(nums, index + 2, end);
        int skip = robLinear(nums, index + 1, end);
        return Math.max(pick, skip);
    }
}
*/

/*
????????????????????????????????????????????????????????????????????????
  ? INCORRECT APPROACH - Backtracking with Visited Array
  (62/75 test cases passed - fails due to incorrect state management)
????????????????????????????????????????????????????????????????????????
  
  Issue: The visited array approach doesn't correctly handle the circular
  constraint. The dependency between first and last house needs to be
  handled by solving two separate linear problems, not through backtracking.

class Solution {
    public int rob(int[] nums) {
        int n = nums.length - 1;
        int[] vis = new int[n+1];
        return robbed(nums, n, vis);
    }

    private int robbed(int[] nums, int currIndex, int[] vis) {
        if (currIndex < 0) return 0;
        if (currIndex == 0 && vis[nums.length-1] == 0) return nums[0];
        if (currIndex == 0 && vis[nums.length-1] == 1) return 0;

        vis[currIndex] = 1;
        int ifPicked = nums[currIndex] + robbed(nums, currIndex - 2, vis);
        vis[currIndex] = 0;
        int ifNotPicked = robbed(nums, currIndex-1, vis);
        return Math.max(ifPicked, ifNotPicked);
    }
}
*/